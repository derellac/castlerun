<!DOCTYPE html>
<html lang="en-US">
	<head>
	<style>
	  body {
      margin: 0px;
      background-color: black;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
	</style>
		<script>
      window.onload = playGame
      var temp
      function playGame() {
        this.canvas = document.getElementsByTagName("canvas").item(0)
        this.ctx = canvas.getContext("2d")
        this.canvas.width = window.innerWidth
        this.canvas.height = window.innerHeight
        this.clean = function() {
          ctx.fillStyle = "rgb(0, 0, 0)"
          ctx.fillRect(0, 0, canvas.width, canvas.height)
        }
        clean()
        function PlayingField() {
          var blocks = [];
          this.offset = 0;
          this.current_level = 0;
          this.raster = 20
          function Player() {
            this.x = 0;
            this.y = 0;
            this.raster = 20
            this.draw = function(offset) {
                ctx.fillStyle = "rgb(220,220,0)"
                ctx.fillRect(canvas.width/this.raster*this.x, canvas.height/this.raster*this.y+offset*canvas.height, canvas.width/this.raster, canvas.height/this.raster)
            }
          }
          this.player = new Player();
          function Block(x,y) {
            this.row = x;
            this.column = y;
            this.raster = 20
            this.color = Math.floor(Math.random() * 120)
            this.draw = function(offset) {
                ctx.fillStyle = "rgba("+this.color+","+this.color+","+this.color+", .9)";
                ctx.strokeStyle = "rgba(120,220,120, .9)";
                ctx.lineWidth = 2
                ctx.beginPath();
                ctx.roundRect(canvas.width/this.raster*this.row, canvas.height/this.raster*this.column+offset*canvas.height, canvas.width/this.raster, canvas.height/this.raster,10);
                ctx.fillRect(canvas.width/this.raster*this.row, canvas.height/this.raster*this.column+offset*canvas.height, canvas.width/this.raster, canvas.height/this.raster)
                ctx.stroke();
            }
            this.at_position = function(x,y) {
              if ((this.row == x) && (this.column == y)) {
                return true
              } else {
                return false
              }
            }
          }
          this.add_path = function(level) {
            x = Math.floor(this.raster/2)
            y = -level * this.raster
            for (var i = 0; i < this.raster;i++) {
              this.remove_block(x,y)
              y += 1
              dx = Math.floor(Math.random()*3)-1
              x += dx
              this.remove_block(x,y-1)
            }
          }
          this.find_block = function(x,y) {
            var found_block = null
            blocks.forEach(block => {
              if (block.at_position(x,y)) {
                found_block = block
              }            
            })
            return found_block
          }
          this.remove_block = function(x,y) {
            var delete_block
            delete_block = this.find_block(x,y)
            if (delete_block != null) {
              blocks.splice(blocks.indexOf(delete_block),1)
            }
          }
          this.init_blocks = function() {
            blocks = []
            this.add_blocks(0)
          }
          this.add_blocks = function(level) {
            for(var i = 0; i < 200; i++) {
              x = Math.floor(Math.random() * this.raster)
              y = Math.floor(Math.random() * this.raster)-level*this.raster
              if (this.find_block(x,y) == null) {
                blocks.push(new Block(x,y))
              }
            }
            this.add_path(level)
          }
          this.draw_blocks = function() {
            blocks.forEach(block => block.draw(this.offset));
          }
          this.obstacle = function(x,y) {
            var obstacles = 0
            blocks.forEach(block => {
              if (block.at_position(x,y)) {
                obstacles++
              }
            });
            if ((x < 0) || (x >= this.raster)) {
              obstacles++
            }
            if (obstacles>0) {
              return true
            } else {
              return false
            }
          }
          this.draw_field = function() {
            this.draw_blocks()
            this.player.draw(this.offset)
          }
          this.refresh = function() {
            clean()
            this.draw_field()
          }
          this.update_offset = function() {
            this.offset = this.offset + 0.002 + this.current_level/1000
            if (this.offset > this.current_level) {
              this.current_level = this.current_level + 1
              this.add_blocks(this.current_level)
            }
          }
          this.start_moving = function() {
            setInterval(this.refresh.bind(this),100)
            setInterval(this.update_offset.bind(this),100)
          }
          this.move_player = function(key) {
            var dx = 0
            var dy = 0
            if (key.keyCode == '37') {
               dx = -1
            }
            if (key.keyCode == '38') {
                dy = -1
            }
            if (key.keyCode == '39') {
               dx = 1
            }
            if (key.keyCode == '40') {
                dy = 1
            }
            if(!this.obstacle(this.player.x+dx,this.player.y+dy)) {
              this.player.x+=dx
              this.player.y+=dy
            }
          }
          document.onkeydown = this.move_player.bind(this);
        }
        t = new PlayingField()
        t.init_blocks()
        t.draw_blocks()        
        t.start_moving()
      }
    </script>
 		<meta charset="utf-8" />
 		<title>Castle Run</title>
 	</head>
  	<body>
		 <canvas width="800" height="600"></canvas>
 	</body>
</html>

